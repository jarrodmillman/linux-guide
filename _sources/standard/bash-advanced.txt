.. _bash-advanced:

*************
Advanced Bash
*************

.. contents::

In order to be of interest to the user, a computer must have a *human interface
component*. If you come from the world of Windows or MacOS, you should be
familiar with the *graphical user interface (GUI)*.  In UNIX, there is another
interface which reigns supreme: the *command line interface (CLI)*. If you have
ever used DOS, you have all ready encountered a CLI; but, you probably have not
been convinced of its usefulness. Simply put, a CLI is a text based interface.
The user is given a *prompt* to indicate the computers reeadiness to accept
*input*. The user enters or types a *command* on the line (or lines) following
the prompt. The computer, consequently, executes or interprets the command and
prompts the user when its finished.

The Interactive Shell
=====================

The program which prompts the user and interprets the user's commands is called
a *shell*. Since Linux' default shell is GNU's **bash** (or the Bourne Again
Shell), I will focus on it. However, the basic ideas are applicable to any of
UNIX's shells.

The shell is an amazingly powerful programming environment---more powerful than
most non-UNIX users are accustomed to. From it you can interactively control
almost any aspect of the OS and more importantly you can automate it. As you
will see, **bash** has a very extensive set of capabalities intended to make
both interactive as well as automated control simple, effective, and
customizable.

Logging In
----------

**Useful Commands**

* :ref:`command-su` -- run a shell with substitute user and group IDs
* :ref:`command-sudo` -- execute a command as another user

Shell Variables
---------------

**Useful Commands**

* :ref:`command-echo` -- display a line of text
* :ref:`command-which` -- shows the full path of (shell) commands.
* :ref:`command-man` -- format and display the on-line manual pages
                     PS1, PATH, CDPATH

**Example 2-1. PS1: Prompt String 1**

::

    [user1@local1 src]$ echo $PS1
    [\u@\h \W]\$
      

**Example 2-2. Changing PS1**

::

    [user1@local1 src]$ PS1=$
    $ bash
    [user1@local1 src]$ export PS1=$
    $ bash
    $
      

**Example 2-3. PATH**

::

    $ echo $PATH
    /bin:/usr/bin:/usr/X11R6/bin:/usr/local/bin
      

**Example 2-4. Finding **echo** with **which****

::

    $ which echo
    /bin/echo
      
      

Entering Commands
-----------------

General Syntax
~~~~~~~~~~~~~~

**Useful Commands**

* :ref:`command-ls` -- list directory contents

While each command has its own syntax, there are some rules usually
followed. Generally, a command line consists of 4 things:

#. command

#. command options

#. arguments

#. line acceptance


**Example 2-6. General Command Syntax**

::

    $ ls --all -l
    total 44
    drwxr-xr-x    2 user1   group1          4096 Feb 26 19:06 .
    drwx------   63 user1   group1         12288 Feb 26 19:04 ..
    -rw-r--r--    1 user1   group1         28251 Feb 26 19:01 manual.xml
    
    $ ls -a -l
    total 44
    drwxr-xr-x    2 user1   group1          4096 Feb 26 19:06 .
    drwx------   63 user1   group1         12288 Feb 26 19:04 ..
    -rw-r--r--    1 user1   group1         28251 Feb 26 19:01 manual.xml
    
    $ ls -al
    total 44
    drwxr-xr-x    2 user1   group1          4096 Feb 26 19:06 .
    drwx------   63 user1   group1         12288 Feb 26 19:04 ..
    -rw-r--r--    1 user1   group1         28251 Feb 26 19:01 manual.xml
    
    $ ls -al manual.xml
    -rw-r--r--    1 user1   group1         28251 Feb 26 19:01 manual.xml
        
      

Command Sequences
~~~~~~~~~~~~~~~~~

Command History and Editing
---------------------------

**Useful Commands**  

* :ref:`command-history` -- lists the history of entered commands

**Example 2-7. Examing your command history with **history****

::

   $ history
     1    echo $PS1
     2    PS1=$
     3    bash
     4    export PS1=$
     5    bash
     6    echo $PATH
     7    which echo
     8    ls --all -l
     9    ls -a -l
     10   ls -al
     11   ls -al manual.xml
        
      

**Example 2-8. Where is the **history** information kept?**

::

    $ echo $HISTFILE
    /group1/user1/.bash_history
    $ echo $HISTSIZE
    1000
      

**Table 2-1. Command History Expansion**

====================   ==========================================================
Designator             Description
====================   ==========================================================
``!!``                 Last command
``!n``                 Command numbered *n* in the history
``!-n``                Command *n* previous
``!string``            Last command starting with *string*
``!?string``           Last command containing *string*
``^string1^string2``   Execute the previous command with *string2*
                       substituted for *string1*
====================   ==========================================================

Command Completion and Substitution
-----------------------------------

**Example 2-9. Command Substitution**

::

        $ ls -l echo
        ls: echo: No such file or directory
        $ ls -l $(which echo)
        -rwxr-xr-x    1 root     root        11704 Mar  7  2002 /bin/echo
      

Shortcuts
---------

**Useful Commands**  

* :ref:`command-clear` -- clear the terminal screen

Aliases -- command shortcuts

Keyboard shorcuts

**Table 2-2. Keyboard Shortcuts**

============   ==========================================================
Key Strokes    Descriptions
============   ==========================================================
*Ctrl-a*       begin of line
*Ctrl-e*       End of file
*Ctrl-k*       Delete line from cursor forward
*Ctrl-d*       EOF; exit
*Ctrl-c*       Interrupt current command
*Ctrl-z*       Suspend current command
*Ctrl-l*       Clear screen
============   ==========================================================

Basic File Management
=====================

Files
-----

**Useful Commands**  

* :ref:`command-stat` -- display file or filesystem status
* :ref:`command-file` --  determine file type
* :ref:`command-type` -- For each *name*, indicate how it would be
                         interpreted if used as a command name.
* :ref:`command-ln` -- make links between files
* :ref:`command-chmod` -- change file access permissions

A file typically consist of these attributes:

-  Name.

-  Type.

-  Location.

-  Size.

-  Protection.

-  Time, date, and user identification.


Examples: chmod -c -v -R

**Example 2-10. Examining File Attributes with **ls**, **stat**, and **file****

::

    $ ls -l
    total 32
    drwxr-xr-x    3 user1   group1          4096 Mar  3 09:58 db2html-dir
    -rw-r--r--    1 user1   group1         48958 Mar  3 09:58 manual.xml
    
    $ stat manual.xml
      File: "manual.xml"
      Size: 48958           Blocks: 96         IO Block: 4096   Regular File
    Device: 7h/7d   Inode: 2204387     Links: 1
    Access: (0644/-rw-r--r--)  Uid: (  503/  user1)   Gid: (  551/     group1)
    Access: Mon Mar  3 09:58:44 2003
    Modify: Mon Mar  3 09:58:43 2003
    Change: Mon Mar  3 09:58:43 2003
    
    $ file manual.xml
    manual.xml: exported SGML document text
      

.. tip:: **Be aware of Magic:**
    The *file* command relies on many sources
    of information to determine what a file contains. The easiest part
    to explain is *magic*. Specifically, the *file* command examines
    the content of the file and compares it with information found in
    the */usr/share/magic/* directory.


**Example 2-11. Creating Symbolic Links with **ln****

::

    $ ln -s db2html-dir unix_users_guide
    $ ls -l
    total 32
    drwxr-xr-x    3 user1   group1          4096 Mar  3 09:58 db2html-dir
    -rw-r--r--    1 user1   group1         48958 Mar  3 09:58 manual.xml
    lrwxrwxrwx    1 user1   group1            11 Mar  3 10:06 unix_users_guide -> db2html-dir
        
      

**Example 2-12. Changing File Attributes with **chmod****

::

   $ chmod g+w manual.xml
   $ ls -l manual.xml
   -rw-rw-r--    1 user1   group1         49889 Mar  3 10:09 manual.xml
        
      

Navigation
----------

**Useful Commands**  

* :ref:`command-cd` -- Change the current working directory to
                     *directory*.
* :ref:`command-pwd` -- print name of current/working directory

**Example 2-13. Moving Around the Filesystem with **cd**, ~,and **pwd****

::

    $ cd ~
    $ pwd
    /home/user1
    

Manipulation
------------

**Useful Commands**  

* :ref:`command-cat` -- concatenate files and print on the standard output
* :ref:`command-cp`-- copy files and directories
* :ref:`command-diff`-- find differences between two files
* :ref:`command-head` -- output the first part of files
* :ref:`command-less` -- opposite of more
* :ref:`command-more` --  file perusal filter for crt viewing
* :ref:`command-mv` -- move (rename) files
* :ref:`command-paste` -- merge lines of files
* :ref:`command-rm` -- remove files or directories
* :ref:`command-rmdir` -- remove empty directories
* :ref:`command-sort` -- sort lines of text files.
* :ref:`command-split` -- split a file into pieces
* :ref:`command-tac` -- concatenate and print files in reverse
* :ref:`command-tail` -- output the last part of files
* :ref:`command-touch` -- change file timestamps
* :ref:`command-uniq` --  remove duplicate lines from a sorted file

Examples: touch, cp, mv, rename...


::

   $ ls 
   dest.txt
   $ cp dest.txt{,.bak}
   $ ls
   dest.txt  dest.txt.bak

**Example 2-14. Manipulating Files with **touch**, **rm**, and **rmdir****

::

    $ touch index.rst; rm _build; rmdir _build
    rm: `_build' is a directory
    rmdir: `_build': Directory not empty
    
    $ rm -Rf _build
    $ ls -l
    total 56
    -rw-rw-r--    1 user1   group1         50939 Mar  3 10:23 index.rst
    lrwxrwxrwx    1 user1   group1            11 Mar  3 10:06 doc -> db2html-dir
    
  

Filename Globbing
-----------------

**Table 2-3. File-Naming Wildcards**

============================== ==================================================
Wildcard                       Function
============================== ==================================================
``*``                          Match zero or more characters.
``?``                          Match exactly one character.
``[characters]``               Match any single character from among *characters*
                                 listed between brackets.
``[!characters]``              Match any single character other than *characters*
                                 listed between brackets.
``[a-z]``                      Match any single character from among the range of
                                 characters listed between brackets.
``[!a-z]``                     Match any single character from among the characters
                                 not in the range listed between brackets
``{frag1, frag2, frag3,...}``  Brace expansion: create strings frag1, frag2, and
                                 frag3, etc.
============================== ==================================================

**Example 2-15. Using brace expansion**

::

   $ echo file{one,two,three}
   fileone filetwo filethree
      

Quoting
-------

**Table 2-4. Quotes**

=================    ====================================
Types of Quoting     Description
=================    ====================================
``' '``              hard quote - no substitution allowed
``" "``              soft quote - allow substitution
``` ```              execute immediately
=================    ====================================



Data Manipulation
=================


Finding Files
-------------

Useful Contents

* :ref:`command-find` --  search for files in a directory hierarchy

**Example 4-1. **find**ing files by name, modification time, and type**

::

    $ find . -name '*.txt'        # find files named *.txt
    $ find . mtime -2             # find files modified less than 2 days ago
    $ find . type l               # find links

Regular Expressions
-------------------

**Table 4-1. Regular Expressions**

Category


**Position anchors**

=========  ====================================================================
Operators  Description
=========  ====================================================================
*^*          Match the beginning of a line.
*$*          Match the end of a line.
=========  ====================================================================

**Character sets**

=============    ====================================================================
Operators        Description
=============    ====================================================================
*[abc]*          Match any single character from from the listed characters
*[a-z]*          Match any single character from the range of characters
*[^abc]*         Match any single character not among listed characters
*[^a-z]*         Match any single character not among listed range of characters
*\\< word\\>*    Match *words* bounded by whitespace.
*.*              Match any single character expcept a *newline*
*\\*             Turn off (escape) the special meaning of a metacharacter
=============    ====================================================================

**Modifiers**

=============    ====================================================================
Operators        Description
=============    ====================================================================
*\**             Match zero or more of the character that precedes it.
*?*              Match zero or one instace of the preceding *regex*.
*+*              Match one or more instances of the preceding *regex*.
*\\{n,m\\}*      Match a range of occurrences of the single character or *regex*
                 that precedes this construct.
*\|*             Match the character or expression to the left or right of the
                 vertical bar.
=============    ====================================================================

.. tip:: **Globs vs. Regex:** 
    Be sure you understand the difference between filename globbing (see
    `the Section called *Filename Globbing* in Chapter 2 <basic-file-management.html#FILENAMEGLOBS>`_)
    and regular expressions.


**ed** and **grep**
-------------------

Useful Contents

* :ref:`command-grep` -- print lines matching a pattern
* :ref:`command-tr` -- translate or delete characters

**Example 4-2. Translating lowercase to UPPERCASE with **tr****

::

    $ echo 'user1'  | tr 'a-z' 'A-Z'
    USER1
        
      

**sed** and **awk**
-------------------

**sed** (stream editor) derives from **ed**.

**Example 4-3. Printing lines of text with **sed****

::

    $ sed -n '1,9p' file.txt       # prints out lines 1-9 of file.txt 
    $ sed -n '/^#/p' file.txt       # prints out lines starting with # of file.txt 
      

**Example 4-4. Deleting lines of text with **sed****

::

    $ sed -e '1,9d' file.txt       # deletes lines 1-9 of file.txt 
    $ sed -e '/^;/d' -e '/^$/d' file.txt       # deletes lines  
      

**Example 4-5. Text substitution with **sed****

::

    $ sed 's/old_pattern/new_pattern/' file.txt > new_file.txt       # replaces only 1st instance in a line 
    $ sed 's/old_pattern/new_pattern/g' file.txt > new_file.txt
      

**Example 4-6. Killing **mozilla** with **awk****

::

    $ ps
          PID TTY          TIME CMD
    17043 pts/2    00:00:00 bash
    17073 pts/2    00:00:09 emacs
    17133 pts/2    00:00:02 mozilla-bin
    17140 pts/2    00:00:00 mozilla-bin 
    17141 pts/2    00:00:00 mozilla-bin
    17142 pts/2    00:00:00 mozilla-bin
    17144 pts/2    00:00:00 mozilla-bin
    17146 pts/2    00:00:00 ps
    
    $ ps | grep mozilla
        17133 pts/2    00:00:02 mozilla-bin
    17140 pts/2    00:00:00 mozilla-bin 
    17141 pts/2    00:00:00 mozilla-bin
    17142 pts/2    00:00:00 mozilla-bin
    17144 pts/2    00:00:00 mozilla-bin
    
    $ ps | grep mozilla | awk '{ print $2 }'
        17133
    17140 
    17141
    17142
    17144
    
    $ ps | grep mozilla | awk '{ print $2 }' | xargs kill -9
    [2]+  Killed                  mozilla
        
      

**perl**
--------

**Example 4-7. Text substitution with **perl****

::

    $ perl -pi -e 's/old_pattern/new_pattern/g' file.txt
    $ perl -pi -e 's/old_pattern/new_pattern/g' $(find . -name \*.html)

The i option tells **perl** to do the global substitution in place.
You can also substitute the **/** with another character. For
example:

::

    $ perl -pi -e 's:old_pattern:new_pattern:g' file.txt
      

**Example 4-8. Summing columns with **perl****

::

    $ perl -lane 'print $F[0] + $F[1]' file.txt       # sums column 1 and 2 of file.txt 
      


Streams, Pipes, and Redirects
=============================

Default File Descriptors
------------------------

**Table 3-1. File Descriptors**

============  ============  ===============
Name          I/O           File Descriptor
============  ============  ===============
stdin         input         0
stdout        output        1
stderr        error output  2
user-defined  input/output  3-19
============  ============  ===============

IO Redirection
--------------

**Table 3-2. Common Redirection Operators**

===========================   ===============================================
Redirection Syntax            Function
===========================   ===============================================
*$ cmd > file*                 Send *stdout* to *file*            
*$ cmd 1> file*                Same as above
*$ cmd 2> file*                Send *stderr* to *file*
*$ cmd > file 2>&1*            Send both *stdout* and *stderr* to *file*
*$ cmd < file*                 Receive *stdin* from *file*
*$ cmd >> file*                Append *stdout* to *file*:
*$ cmd 1>> file*               Same as above
*$ cmd 2>> file*               Append *stderr* to *file*
*$ cmd >> file 2>&1*           Append both *stdout* and *stderr* to *file*
*$ cmd1 \| cmd2*               Pipe *stdout* from *cmd1* to *cmd2*
*$ cmd1 2>&1 \| cmd2*          Pipe *stdout* and *stderr* from *cmd1* to *cmd2*
*$ cmd1 tee file1 \| cmd2*     Pipe *stdout* and *cmd1* to *cmd2* while
                               simultaneously writing it to *file1*
                               using *tee*
===========================   ===============================================

Standard Redirection
~~~~~~~~~~~~~~~~~~~~

Pipes
~~~~~

Useful Contents

* :ref:`command-wc` --  print the number of bytes, words, and lines in
  files

**Example 3-1. A simple pipe to **wc****

::

        $ echo "hey there" | wc -w
              2
      

The **xargs** and **tee** Command
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Useful Contents

* :ref:`command-xargs` --  build and execute command lines from
  standard input
* :ref:`command-tee` -- read from standard input and write to standard
  output and files



Creating, Monitoring, and Killing Processes
===========================================

Processes
---------

Processes have the following attributes:

-  A lifetime.

-  A PID.

-  A UID.

-  A GID.

-  A parent process.

-  An environment.

-  A current working directory.


Monitoring Processes
--------------------

Useful Contents

* :ref:`command-ps` --  report process status
* :ref:`command-pstree` -- display a tree of processes
* :ref:`command-top` -- display top CPU processes

**Example 3-2. Examining Processes with **ps****

::

        $ ps
          PID TTY          TIME CMD
        29982 pts/1    00:00:00 bash
        30042 pts/1    00:00:00 gvim
        30162 pts/1    00:00:00 ps
        
        $ ps -f
        UID        PID  PPID  C STIME TTY          TIME CMD
        user1   29982 29981  0 17:04 pts/1    00:00:00 /bin/bash
        user1   30042 29982  0 17:05 pts/1    00:00:00 gvim manual.xml
        user1   30161 29982  0 17:11 pts/1    00:00:00 ps -f
        
        $ ps -lf
          F S UID        PID  PPID  C PRI  NI ADDR    SZ WCHAN  STIME TTY          TIME CMD
        000 S user1   29982 29981  0  75   0    -   712 wait4  17:04 pts/1    00:00:00 /bin/bash
        000 S user1   30042 29982  0  75   0    -  2849 schedu 17:05 pts/1    00:00:01 emacs manual.xml
        000 R user1   30238 29982  0  76   0    -   855 -      17:16 pts/1    00:00:00 ps -lf
        
      

**Example 3-3. Examining Processes with **pstree****

::

        $ pstree
        init-+-alarmd
             |-atd
             |-bdflush
             |-crond
             |-cupsd
             |-gkrellm
             |-gpm
             |-7*[kdeinit]
             |-kdeinit-+-kdeinit
             |         |-konsole---bash-+-emacs
             |         |                `-pstree
             |         `-soundwrapper---mozilla-bin---mozilla-bin---4*[mozilla-bin]
             |-kdeinit---cat
             |-kdm-+-X
             |     `-kdm---startkde-+-ksmserver
             |                      `-ssh-agent
             |-sshd
             |-syslogd
             |-xfs
             |-xinetd
             `-ypbind---ypbind
        
      

**Example 3-4. Examining Processes with **top****

::

        $ top
          5:18pm  up 2 days, 13:26,  2 users,  load average: 0.03, 0.03, 0.00
        76 processes: 75 sleeping, 1 running, 0 zombie, 0 stopped
        CPU0 states:  0.4% user,  0.3% system,  0.0% nice, 98.3% idle
        CPU1 states:  0.0% user,  0.4% system,  0.0% nice, 99.1% idle
        Mem:  2068644K av, 1001668K used, 1066976K free,       0K shrd,  218192K buff
        Swap:  401584K av,       0K used,  401584K free                  339532K cached
        
          PID USER     PRI  NI  SIZE  RSS SHARE STAT %CPU %MEM   TIME COMMAND
         1840 root       5 -10  284M  28M  4340 S <   0.9  1.4  10:24 X
        29981 user1    15   0 13504  13M  8120 S     0.7  0.6   0:01 konsole
        30296 user1    15   0  1188 1188   928 R     0.3  0.0   0:00 top
            1 root      15   0   504  504   440 S     0.0  0.0   0:05 init
        
      

Signaling Processes
-------------------

Useful Contents

* :ref:`command-kill` -- terminate a process
* :ref:`command-killall` --  kill processes by name

**Table 3-3. Common Signals**

============= =================================  ====
Signal Number Meaning                            HUP
============= =================================  ====
1             Hangup, reread configuration       INT
2             Interrupt, stop running            KILL
9             Stop immediately                   TERM
15            Terminate nicely                   TSTP
18            Stop executing, ready to continue
============= =================================  ====

.. _tip: **Zombies:**
    Occasionally, a process monitor like **ps** or **top**
    will list a process as a *zombie*. This is a process with has
    gotten stuck while terminating. As you would expect you cannot kill
    a *zombie* as its all ready dead. If an application repeatedly
    becomes a *zombie* when killed, there's a good chance there's an
    underlying bug in the application.


Shell Job Control
-----------------

Useful Contents

* :ref:`command-bg` -- background
* :ref:`command-fg` -- foreground
* :ref:`command-jobs` -- list the active jobs
* :ref:`command-nohup` -- Run a command immune to hangups, with
  output to a non-tty

bg,fg,jobs,Ctrl-C,Ctrl-Z

